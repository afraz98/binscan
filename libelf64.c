
/*libelf parsing adapted from source code generated by Joseph Koshy for "libelf by Example".
  For more information please visit https://sourceforge.net/projects/elftoolchain/files/Documentation/libelf-by-example/*/
#include "bin/libelf64.h"
#include "bin/binproto.h"

#include <stdio.h> 
#include <stdint.h> 
#include <stdlib.h> 

#include <unistd.h> 
#include <fcntl.h>
#include <string.h>

#include <capstone/capstone.h>
#include <openssl/sha.h>
#include <openssl/evp.h>

#define LONGESTOPCODE 10

int checkElf64(Elf *e){
  int i;
  if ((i = gelf_getclass(e)) == ELFCLASSNONE)
    errx(EXIT_FAILURE , "getclass() failed: %s.",elf_errmsg(-1));
  if(i == ELFCLASS32){
	return 0;
  } else return 1; 
}

Elf *openELF(char *file, int fd){
  Elf *e;
  if ((e = elf_begin(fd, ELF_C_READ, NULL)) == NULL) errx(EXIT_FAILURE , "elf_begin() failed: %s.",elf_errmsg(-1));
  if (elf_kind(e) != ELF_K_ELF) errx(EXIT_FAILURE , "\"%s\" is not an ELF-64 object.", file);
  return e; 
}

GElf_Shdr findTextSection(Elf *e, Elf_Scn **s){
  char *name = "";
  size_t shstrndx;
  GElf_Shdr shdr;
  
  if (elf_getshdrstrndx(e, &shstrndx) != 0) errx(EXIT_FAILURE, "elf_getshdrstrndx() failed: %s.", elf_errmsg(-1));
  *s = NULL;
  while ((*s = elf_nextscn(e,*s)) != NULL){ //Find ".text" section by name                                                                                                                                       
    if (gelf_getshdr(*s, &shdr) != &shdr) errx(EXIT_FAILURE, "getshdr() failed: %s.", elf_errmsg(-1));

    if((name = elf_strptr (e,shstrndx,shdr.sh_name)) == NULL)
      errx(EXIT_FAILURE, "elf_strptr() failed: %s.", elf_errmsg ( -1));

    if(strcmp(name, ".text") == 0){ break; }
  } return shdr; 
}

IBuffer printInstructions(unsigned char* buffer, size_t buffersize, uint64_t address){
  /************************************* PARSE INSTRUCTIONS *****************************************************/
  /*Adapted from Capstone Library C Demonstration.
    For more information visit https://www.capstone-engine.org/lang_c.html*/
  
  csh handle;
  cs_insn *insn;
  size_t count;
  IBuffer ib;
  ib.ninstructions = 0; 
  /*From Project 1 2019 Demo*/
  if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle)) {
    printf("ERROR: Failed to initialize engine!\n");
    return ib;
  }
  
  count = cs_disasm(handle, buffer, buffersize, address, 0, &insn);
  int isUnique = 1;
  printf("%lu instructions\n\n", count);
  if (count){
    for (size_t j = 0; j < count; j++) {
      isUnique = 1; 
      for(size_t is = 0; is < ib.ninstructions; is++){
	if(strcmp(ib.instructions[is].instruction, insn[j].mnemonic) == 0) isUnique = 0; 
      }
      
      if(isUnique){
	strcpy(ib.instructions[ib.ninstructions].instruction, insn[j].mnemonic);
	ib.ninstructions++;
      }
    }

    for(size_t m = 0; m < ib.ninstructions; m++){
      ib.instructions[m].instruction_calls = 1;
      for(size_t j = 0; j < count; j++){
	if(strcmp(ib.instructions[m].instruction, insn[j].mnemonic) == 0) ib.instructions[m].instruction_calls++;
      } printf("%s\t%d\n", ib.instructions[m].instruction, ib.instructions[m].instruction_calls);
    }
    cs_free(insn, count);
  }
  else {
    printf("ERROR: Failed to disassemble given code!\n");
  }  cs_close(&handle);

  return ib; 
}

IBuffer parseSectionText(Elf *e){
  Elf_Scn *scn; 
  Elf_Data *data; 
  GElf_Shdr shdr;
  IBuffer instructions;
  
  shdr = findTextSection(e,&scn); 
  data = NULL; 
  data = elf_getdata(scn, data); 
  
  printf(".text\n");
  printf("Section starts at 0x%lx\n", shdr.sh_addr);
  printf("Section length: 0x%lx\n", shdr.sh_size);
  
  unsigned char *p;
  p = (unsigned char *)data->d_buf;
  instructions = printInstructions(p, data->d_size, shdr.sh_addr);
  return instructions; 
}

void printSHA1(Elf *e, unsigned char *sha_value){
  Elf_Scn *scn;
  Elf_Data *data;
  SHA_CTX sha1ctx;  
  
  
  findTextSection(e, &scn); 
  data = NULL;
  data = elf_rawdata(scn, data); //Retrieve raw byte data of .text section
  unsigned char *p = (unsigned char *) data->d_buf; //Make byte pointer of data buffer pointer
  SHA1_Init(&sha1ctx);
  
  /*SHA1 Hash Calculation adapted from EVP Library Demonstration by Steve Tate.
   For more information visit https://www.uncg.edu/cmp/faculty/srtate/580.f11/sha1examples.php*/
  
  while(p < (unsigned char *) (data->d_buf + data->d_size)){
    //UPDATE SHA1 Hash variable
   SHA1_Update(&sha1ctx, p, sizeof(unsigned char));
   p++; 
  } SHA1_Final(sha_value, &sha1ctx); 
  
  printf("SHA1: ");
  for(int i = 0; i < SHA_DIGEST_LENGTH; i++){
    printf("%02x", sha_value[i]);
  } printf("\n");
}

int fillFileBuffer(uint8_t *buffer, char *argfile, uint8_t *sha1, IBuffer ib){
  uint8_t *bptr = buffer;
  strncpy(((FileHeader *)buffer)->file_name, argfile, sizeof(((FileHeader *)buffer)->file_name)-1);
  bptr += sizeof(FileHeader);
  
  ((SHA1Record *)bptr)->et = SHA1_RECORD;
  memcpy(&((SHA1Record *)bptr)->sha1, sha1, sizeof((SHA1Record *)bptr)->sha1);
  ((FileHeader *)buffer)->data_length += sizeof(SHA1Record);
  bptr += sizeof(SHA1Record); 
  
  //((IBuffer *)bptr)->et = I_BUFFER;
  //memcpy(&((IBuffer *)bptr)->instructions, ib.instructions, sizeof((IBuffer *)bptr)->instructions);
  //((IBuffer *)bptr)->ninstructions = ib.ninstructions;
  //((FileHeader *)buffer)->data_length += sizeof(IBuffer);
  return sizeof(FileHeader) + ((FileHeader *)buffer)->data_length; 
}


/*
  Procedure:
  
  1. Open ELF-64 argument from file
  2. Print SHA1 Hash for .text section byte data
  3. Parse '.text' section data for instructions
  4. Print unique instructions with amount of calls 
*/

/*Source code adapted from Project 1 Example from 2019 given.*/
void parseElf(char *file) {
  int fd;
  Elf *e;
  char *outputfile;
  FILE *outfile;
  uint8_t buffer[0x5000]; 
  unsigned char sha1[SHA_DIGEST_LENGTH]; 
  int recordsize;
  IBuffer ib; 
  
  if (elf_version(EV_CURRENT) == EV_NONE) errx(EXIT_FAILURE , "ELF library initialization failed: %s", elf_errmsg(-1));

  if ((fd = open(file, O_RDONLY, 0)) < 0)
    err(EXIT_FAILURE , "open \"%s\" failed", file);

  
  e = openELF(file, fd);
  if(!checkElf64(e)) printf("%s is not an ELF-64 object.\n\n", file);

  //Print SHA1 Hash of .text section
  printSHA1(e, sha1);
  printf("\n");

  //Print unique instructions with call counts
  ib = parseSectionText(e);
  printf("\n");

  //Close ELF Object, File
  elf_end(e);
  close(fd);
  
  //Generate output file name from file argument
  outputfile = malloc(strlen(file) + strlen(".bin")) + 1;
  outputfile[0] = '\0';
  strcat(outputfile, file);
  strcat(outputfile, ".bin");

  //Write contents to file
  recordsize = fillFileBuffer(buffer, file, sha1, ib);
  outfile = fopen(outputfile, "ab+");
  fwrite(buffer, sizeof(uint8_t), recordsize, outfile);
  fwrite(&ib, sizeof(IBuffer), 1, outfile);
  fflush(outfile);
  fclose(outfile);
  exit(EXIT_SUCCESS);
}

