
/*Adapted from source code generated by Joseph Koshy for "libelf by Example"*/
#include "bin/libelf64.h"

#include <stdio.h> 
#include <stdint.h> 
#include <stdlib.h> 

#include <unistd.h> 
#include <fcntl.h>
#include <string.h>

#include <capstone/capstone.h>
#include <openssl/evp.h>

#define LONGESTOPCODE 10

int checkElf64(Elf *e){
  int i;
      if ((i = gelf_getclass(e)) == ELFCLASSNONE)
        errx(EXIT_FAILURE , "getclass() failed: %s.",elf_errmsg(-1));
      if(i == ELFCLASS32){
	return 0;
      } else return 1; 
}

Elf *openELF(char *file, int fd){
  Elf *e;
  if ((e = elf_begin(fd, ELF_C_READ, NULL)) == NULL) errx(EXIT_FAILURE , "elf_begin() failed: %s.",elf_errmsg(-1));
  if (elf_kind(e) != ELF_K_ELF) errx(EXIT_FAILURE , "\"%s\" is not an ELF-64 object.", file);
  return e; 
}

void printElfHeader(Elf *e){
  GElf_Ehdr ehdr;
  if (gelf_getehdr(e, &ehdr) == NULL) errx(EXIT_FAILURE , "getehdr() failed: %s.",elf_errmsg(-1));
  
  size_t n; 
  PRINT_FIELD(e_type);  printf("\n");
  PRINT_FIELD(e_machine); printf("\n");
  PRINT_FIELD(e_version); printf("\n");
  PRINT_FIELD(e_entry); printf("\n");
  PRINT_FIELD(e_phoff); printf("\n");
  PRINT_FIELD(e_shoff); printf("\n");
  PRINT_FIELD(e_flags); printf("\n");
  PRINT_FIELD(e_ehsize); printf("\n");
  PRINT_FIELD(e_phentsize); printf("\n");
  PRINT_FIELD(e_shentsize); printf("\n");
  printf("\n");
  
  if (elf_getshdrnum(e, &n) != 0) errx(EXIT_FAILURE , "getshdrnum()␣failed:␣%s.",elf_errmsg(-1));
  printf(PRINT_FMT , "(shnum)", (uintmax_t) n); printf("\n");
  
  if (elf_getshdrstrndx(e, &n) != 0) errx(EXIT_FAILURE , "getshdrstrndx()␣failed:␣%s.",elf_errmsg(-1));
  printf(PRINT_FMT , "(shstrndx)", (uintmax_t) n); printf("\n");
}

void printp_type(size_t pt){
	char *s; 
	#define C(V) case PT_##V: s = #V; break
	switch(pt){
		C(NULL);	C(LOAD);	C(DYNAMIC);
		C(INTERP);	C(NOTE);	C(SHLIB);
		C(PHDR);	C(TLS);	//C(SUNW_UNWIND);
		//C(SUNWBSS);	//C(SUNWSTACK);//C(SUNWDTRACE);
		//C(SUNWCAP);
	default:
		s = "";
		break;
	}
	printf(" \"%s\"", s);
	#undef C
}

void printProgramHeaders(Elf *e){
  size_t n;   GElf_Phdr phdr;  
  if (elf_getphdrnum(e, &n) != 0) errx(EXIT_FAILURE , "getphdrnum()␣failed: %s.",elf_errmsg(-1));
  
  printf(PRINT_FMT , "(phnum)", (uintmax_t) n);
  printf("\n\n");
  
  for(int j = 0; j < n; j++){
  	if(gelf_getphdr(e, j, &phdr) != &phdr) errx(EXIT_FAILURE, "getphdr() failed: %s", elf_errmsg(-1));
	printf("PHDR %d: \n" , j);
  	PRINT_PHDRFIELD(p_type);
  	printp_type(phdr.p_type); printf("\n");
  	PRINT_PHDRFIELD(p_offset); printf("\n");
  	PRINT_PHDRFIELD(p_vaddr); printf("\n");
  	PRINT_PHDRFIELD(p_paddr); printf("\n");
  	PRINT_PHDRFIELD(p_filesz); printf("\n");
  	PRINT_PHDRFIELD(p_memsz); printf("\n");
  	PRINT_PHDRFIELD(p_flags); 
  	
  	if(phdr.p_flags & PF_X) printf(" [EXECUTE] "); 
  	if(phdr.p_flags & PF_R) printf(" [READ] ");
  	if(phdr.p_flags & PF_W) printf(" [WRITE] ");
  	
  	printf("\n");
  	PRINT_PHDRFIELD(p_align); printf("\n\n");
  }
}

void printSections(Elf *e){
  Elf_Scn *scn;
  GElf_Shdr shdr;
  size_t shstrndx;
  char *name;
  
  if (elf_getshdrstrndx(e, &shstrndx) != 0)
    errx(EXIT_FAILURE, "elf_getshdrstrndx() failed: %s.", elf_errmsg(-1));
  
  scn = NULL;
  while ((scn = elf_nextscn(e,scn)) != NULL){ //Print sections by name
    if (gelf_getshdr(scn, &shdr) != &shdr)
      errx(EXIT_FAILURE, "getshdr() failed: %s.", elf_errmsg(-1));
    if(( name = elf_strptr (e , shstrndx , shdr.sh_name )) == NULL)
      errx(EXIT_FAILURE, "elf_strptr() failed: %s.", elf_errmsg ( -1));
    printf("Section %-4.4jd %s\n ", (uintmax_t)elf_ndxscn(scn), name);
  } printf("\n");
}

void printInstructions(unsigned char* buffer, size_t buffersize, uint64_t address){
  /************************************* PARSE INSTRUCTIONS *****************************************************/
  /*Adapted from Capstone Library C Demonstration*/
  csh handle;
  cs_insn *insn;
  size_t count, unique = 0;
  
  /*From Project 1 2019 Demo*/
  if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle)) {
    printf("ERROR: Failed to initialize engine!\n");
    return;
  }
  
  count = cs_disasm(handle, buffer, buffersize, address, 0, &insn);
  char instructions[count][LONGESTOPCODE];
  int isUnique = 1;
  printf("%lu instructions\n\n", count);
  if (count){
    for (size_t j = 0; j < count; j++) {
      isUnique = 1; 
      for(size_t is = 0; is < unique; is++){
	if(strcmp(instructions[is], insn[j].mnemonic) == 0) isUnique = 0; 
      }
      
      if(isUnique){
	strcpy(instructions[unique], insn[j].mnemonic);
	unique++;
      }
    }

    int counter; 
    for(size_t m = 0; m < unique; m++){
      counter = 1;
      for(size_t j = 0; j < count; j++){
	if(strcmp(instructions[m], insn[j].mnemonic) == 0) counter++;
      } printf("%s\t%d\n", instructions[m], counter);
    }
    cs_free(insn, count);
  }
  else {
    printf("ERROR: Failed to disassemble given code!\n");
  }  cs_close(&handle);
}

void parseSectionText(Elf *e){
  size_t n; 
  Elf_Scn *scn;
  Elf_Data *data; 
  GElf_Shdr shdr;
  size_t shstrndx;
  char *name = "";
  
  if (elf_getshdrstrndx(e, &shstrndx) != 0)
    errx(EXIT_FAILURE, "elf_getshdrstrndx() failed: %s.",
	 elf_errmsg(-1));
  scn = NULL; 
  while ((scn = elf_nextscn(e,scn)) != NULL){ //Find ".text" section by name 
    if (gelf_getshdr(scn, &shdr) != &shdr)
      errx(EXIT_FAILURE, "getshdr() failed: %s.", elf_errmsg(-1));
    
    if((name = elf_strptr (e,shstrndx,shdr.sh_name )) == NULL)
      errx(EXIT_FAILURE, "elf_strptr() failed: %s.", elf_errmsg ( -1));
    
    if(strcmp(name, ".text") == 0){ break; }
  }
  
  
  data = NULL; n = 0; 
  data = elf_getdata(scn, data); 

  printf(".text\n");
  printf("Section starts at 0x%lx\n", shdr.sh_addr); 
  printf("Section length: 0x%lx\n", shdr.sh_size);

  unsigned char *p;
  do{
    p = (unsigned char *)data->d_buf;
    printInstructions(p, data->d_size, shdr.sh_addr);
    n++; p++;
  }while(n < shdr.sh_size && (data = elf_getdata(scn, data)) != NULL);  
  
}

void printSHA1(Elf *e){
  Elf_Scn *scn;
  Elf_Data *data;
  GElf_Shdr shdr;
  size_t shstrndx;
  char *name = "";
  
  EVP_MD_CTX *mdctx; 
  const EVP_MD *md; 
  unsigned char md_value[EVP_MAX_MD_SIZE];
  unsigned int md_len;
 
  if (elf_getshdrstrndx(e, &shstrndx) != 0) errx(EXIT_FAILURE, "elf_getshdrstrndx() failed: %s.",elf_errmsg(-1));

  scn = NULL; 
  while ((scn = elf_nextscn(e,scn)) != NULL){ //Find ".text" section by section name
    if (gelf_getshdr(scn, &shdr) != &shdr)
      errx(EXIT_FAILURE, "getshdr() failed: %s.", elf_errmsg(-1));

    if((name = elf_strptr (e,shstrndx,shdr.sh_name )) == NULL)
      errx(EXIT_FAILURE, "elf_strptr() failed: %s.", elf_errmsg ( -1));

    if(strcmp(name, ".text") == 0){ break; }
  }

  
  data = NULL;
  data = elf_rawdata(scn, data); //Retrieve raw byte data of .text section
  unsigned char *p = (unsigned char *) data->d_buf; //Make byte pointer of data buffer pointer

  OpenSSL_add_all_digests();
  md = EVP_get_digestbyname("SHA1");

  mdctx = EVP_MD_CTX_create();
  EVP_DigestInit_ex(mdctx, md, NULL);
  
  while(p < (unsigned char *) (data->d_buf + data->d_size)){
    //UPDATE SHA1 Hash variable
    EVP_DigestUpdate(mdctx, p, sizeof(unsigned char));
    p++; 
  } EVP_DigestFinal_ex(mdctx, md_value, &md_len);
  EVP_MD_CTX_destroy(mdctx);

  printf("SHA1: ");
  for(int i = 0; i < md_len; i++){
    printf("%02x", md_value[i]);
  } printf("\n");
  

  /* Call this once before exit. */
  EVP_cleanup();
}


/*
  Procedure:

  1. Open ELF-64 argument from file
  2. Print ELF Identifier
  3. Print ELF File Header
  4. Print ELF Program Headers
  5. Print ELF Section Names
  6. Parse '.text' section data for instructions
*/

void parseElf(int argc, char **argv) {
  //int i;
  int fd;
  Elf *e;
  char *id;


  if (argc < 2)
    errx(EXIT_FAILURE, "Please provide a file argument.");
  if (elf_version(EV_CURRENT) == EV_NONE) errx(EXIT_FAILURE , "ELF library initialization "
					       "failed: %s", elf_errmsg(-1));

  if ((fd = open(argv[1], O_RDONLY, 0)) < 0)
    err(EXIT_FAILURE , "open \"%s\" failed", argv[1]);

  
  e = openELF(argv[1], fd);
  if(!checkElf64(e)) printf("%s is not an ELF-64 object.\n\n", argv[1]);
  
  if ((id = elf_getident(e, NULL)) == NULL)
    errx(EXIT_FAILURE , "getident() failed: %s.",elf_errmsg(-1));

  /*
    printf("%3s e_ident[0..%1d] %7s", " ", EI_ABIVERSION , " ");
    for (i = 0; i <= EI_ABIVERSION; i++) { 
    printf("0x%.2X ",id[i]);
    } printf("\n");
    
    printElfHeader(e);
    printProgramHeaders(e);
    printSections(e);
  */
  printSHA1(e);
  printf("\n");
  parseSectionText(e);
  printf("\n");
  
  elf_end(e);
  close(fd); 
  exit(EXIT_SUCCESS);
}

