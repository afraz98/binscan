
/*libelf parsing adapted from source code generated by Joseph Koshy for "libelf by Example".
  For more information please visit https://sourceforge.net/projects/elftoolchain/files/Documentation/libelf-by-example/*/
#include "bin/libelf64.h"
#include "bin/binproto.h"

#include <stdio.h> 
#include <stdint.h> 
#include <stdlib.h> 

#include <unistd.h> 
#include <fcntl.h>
#include <string.h>

#include <capstone/capstone.h>
#include <openssl/sha.h>
#include <openssl/evp.h>
#include <math.h>

int checkElf64(Elf *e){
  int i;
  if ((i = gelf_getclass(e)) == ELFCLASSNONE)
    errx(EXIT_FAILURE , "getclass() failed: %s.",elf_errmsg(-1));
  if(i == ELFCLASS32){
	return 0;
  } else return 1; 
}

Elf *openELF(char *file, int fd){
  Elf *e;
  if ((e = elf_begin(fd, ELF_C_READ, NULL)) == NULL) errx(EXIT_FAILURE , "elf_begin() failed: %s.",elf_errmsg(-1));
  if (elf_kind(e) != ELF_K_ELF) errx(EXIT_FAILURE , "\"%s\" is not an ELF-64 object.", file);
  return e; 
}

GElf_Shdr findTextSection(Elf *e, Elf_Scn **s){
  char *name = "";
  size_t shstrndx;
  GElf_Shdr shdr;
  
  if (elf_getshdrstrndx(e, &shstrndx) != 0) errx(EXIT_FAILURE, "elf_getshdrstrndx() failed: %s.", elf_errmsg(-1));
  *s = NULL;
  while ((*s = elf_nextscn(e,*s)) != NULL){ //Find ".text" section by name                                                                                                                                       
    if (gelf_getshdr(*s, &shdr) != &shdr) errx(EXIT_FAILURE, "getshdr() failed: %s.", elf_errmsg(-1));

    if((name = elf_strptr (e,shstrndx,shdr.sh_name)) == NULL)
      errx(EXIT_FAILURE, "elf_strptr() failed: %s.", elf_errmsg ( -1));

    if(strcmp(name, ".text") == 0){ break; }
  } return shdr; 
}

IBuffer printInstructions(unsigned char* buffer, size_t buffersize, uint64_t address){
  /************************************* PARSE INSTRUCTIONS *****************************************************/
  /*Adapted from Capstone Library C Demonstration.
    For more information visit https://www.capstone-engine.org/lang_c.html*/
  
  csh handle;
  cs_insn *insn;
  size_t count;
  IBuffer ib;
  ib.ninstructions = 0; 
  /*From Project 1 2019 Demo*/
  if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle)) {
    printf("ERROR: Failed to initialize engine!\n");
    return ib;
  }
  
  count = cs_disasm(handle, buffer, buffersize, address, 0, &insn);
  int isUnique = 1;
  printf("%lu instructions\n\n", count);
  if (count){
    for (size_t j = 0; j < count; j++) {
      isUnique = 1; 
      for(size_t is = 0; is < ib.ninstructions; is++){
	if(strcmp(ib.instructions[is].instruction, insn[j].mnemonic) == 0) isUnique = 0; 
      }
      
      if(isUnique){
	strcpy(ib.instructions[ib.ninstructions].instruction, insn[j].mnemonic);
	ib.ninstructions++;
      }
    }

    for(size_t m = 0; m < ib.ninstructions; m++){
      ib.instructions[m].instruction_calls = 1;
      for(size_t j = 0; j < count; j++){
	if(strcmp(ib.instructions[m].instruction, insn[j].mnemonic) == 0) ib.instructions[m].instruction_calls++;
      } printf("%s\t%d\n", ib.instructions[m].instruction, ib.instructions[m].instruction_calls);
    }
    cs_free(insn, count);
  }
  else {
    printf("ERROR: Failed to disassemble given code!\n");
  }  cs_close(&handle);

  return ib; 
}

IBuffer parseSectionText(Elf *e){
  Elf_Scn *scn; 
  Elf_Data *data; 
  GElf_Shdr shdr;
  IBuffer instructions;
  
  shdr = findTextSection(e,&scn); 
  data = NULL; 
  data = elf_getdata(scn, data); 
  
  printf(".text\n");
  printf("Section starts at 0x%lx\n", shdr.sh_addr);
  printf("Section length: 0x%lx\n", shdr.sh_size);
  
  unsigned char *p;
  p = (unsigned char *)data->d_buf;
  instructions = printInstructions(p, data->d_size, shdr.sh_addr);
  return instructions; 
}

MD5Record printMD5(Elf *e){
  MD5Record record;
  Elf_Scn *scn;
  Elf_Data *data;
  EVP_MD_CTX *mdctx;
  unsigned int md5_length;

  mdctx = EVP_MD_CTX_create();
  EVP_DigestInit_ex(mdctx, EVP_md5(), NULL);
  
  findTextSection(e, &scn);
  data = NULL;
  data = elf_rawdata(scn, data); //Retrieve raw byte data of .text section
  unsigned char *p = (unsigned char *) data->d_buf; //Make byte pointer of data buffer pointer
  while(p < (unsigned char *) (data->d_buf + data->d_size)){
    EVP_DigestUpdate(mdctx, p, sizeof(unsigned char));
    p++;
  } EVP_DigestFinal_ex(mdctx, record.md5, &md5_length); 

  EVP_MD_CTX_destroy(mdctx);
  
  printf("MD5: ");
  for(int i = 0; i < MD5_DIGEST_LENGTH; i++){
    printf("%02x", record.md5[i]);
  } printf("\n");

  return record; 
}

void printSHA1(Elf *e, unsigned char *sha_value){
  Elf_Scn *scn;
  Elf_Data *data;
  SHA_CTX sha1ctx;  
  
  
  findTextSection(e, &scn); 
  data = NULL;
  data = elf_rawdata(scn, data); //Retrieve raw byte data of .text section
  unsigned char *p = (unsigned char *) data->d_buf; //Make byte pointer of data buffer pointer
  SHA1_Init(&sha1ctx);
  
  /*SHA1 Hash Calculation adapted from EVP Library Demonstration by Steve Tate.
   For more information visit https://www.uncg.edu/cmp/faculty/srtate/580.f11/sha1examples.php*/
  
  while(p < (unsigned char *) (data->d_buf + data->d_size)){
    //UPDATE SHA1 Hash variable
   SHA1_Update(&sha1ctx, p, sizeof(unsigned char));
   p++; 
  } SHA1_Final(sha_value, &sha1ctx); 
  
  printf("SHA1: ");
  for(int i = 0; i < SHA_DIGEST_LENGTH; i++){
    printf("%02x", sha_value[i]);
  } printf("\n");
}

/*fillFileBuffer adapted from Project 1 Example from 2019 given.*/
int fillFileBuffer(uint8_t *buffer, char *argfile, uint8_t *sha1, IBuffer ib){
  uint8_t *bptr = buffer;
  strncpy(((FileHeader *)buffer)->file_name, argfile, sizeof(((FileHeader *)buffer)->file_name)-1);
  bptr += sizeof(FileHeader);
  
  ((SHA1Record *)bptr)->et = SHA1_RECORD;
  memcpy(&((SHA1Record *)bptr)->sha1, sha1, sizeof((SHA1Record *)bptr)->sha1);
  ((FileHeader *)buffer)->data_length += sizeof(SHA1Record);
  bptr += sizeof(SHA1Record); 
  return sizeof(FileHeader) + ((FileHeader *)buffer)->data_length; 
}

RenyiEntropy calculateEntropy(Elf *e){
  RenyiEntropy r;  
  
  Elf_Scn *scn;
  Elf_Data *data;
  unsigned char* start, *next;
  findTextSection(e, &scn);
  data = NULL; data = elf_rawdata(scn, data);

  double num_bytes = 0; 
  start = data->d_buf; //Point to start of section data
  while(start < (unsigned char*) (data->d_buf + data->d_size)){
    start++; num_bytes++;
  } printf("%d bytes in section .text\n", (int) num_bytes);

  double frequency = 0;
  double probability_sum = 0.0; 
  start = data->d_buf;

  while(start < (unsigned char*) (data->d_buf + data->d_size)){
    next = start;
    next++;
    frequency = 1; 
    while(next < (unsigned char*) (data->d_buf + data->d_size)){
      if(*next == *start){
	frequency++;
      } next++; 
    }

    probability_sum += pow((frequency/num_bytes),2);
    probability_sum = 1 / probability_sum;
    start++; 
  }

  r.entropy = log(probability_sum) / log(256);
  if(r.entropy < 0.0) r.entropy *= -1; 
  printf("Renyi Entropy: %lf\n", r.entropy);
  return r; 
}


/*
  Procedure:
  
  1. Open ELF-64 argument from file
  2. Print SHA1 Hash for .text section byte data
  3. Parse '.text' section data for instructions
  4. Print unique instructions with amount of calls 
  5. Calculate Renyi Entropy for bytes of text section
  6. Write contents to '[argfile].bin' 
*/

void parseElf(char *file) {
  int fd;
  Elf *e;
  char *outputfile;
  FILE *outfile;
  uint8_t buffer[0x6000]; 

  int recordsize;
  IBuffer ib; 
  RenyiEntropy r; 
  MD5Record rmd5;
  unsigned char sha1[SHA_DIGEST_LENGTH];
  
  if (elf_version(EV_CURRENT) == EV_NONE) errx(EXIT_FAILURE , "ELF library initialization failed: %s", elf_errmsg(-1));

  if ((fd = open(file, O_RDONLY, 0)) < 0)
    err(EXIT_FAILURE , "open \"%s\" failed", file);

  
  e = openELF(file, fd);
  if(!checkElf64(e)) printf("%s is not an ELF-64 object.\n\n", file);

  //Print SHA1 Hash of .text section
  printSHA1(e, sha1);
  printf("\n");

  //Print unique instructions with call counts
  ib = parseSectionText(e);
  printf("\n");

  //Print Renyi Entropy of .text section
  r = calculateEntropy(e); 

  //Print MD5 Checksum of .text section
  rmd5 = printMD5(e);
  
  //Close ELF Object, File
  elf_end(e);
  close(fd);
  
  //Generate output file name from file argument
  outputfile = malloc(strlen(file) + strlen(".bin")) + 1;
  outputfile[0] = '\0';

  strcat(outputfile, file);
  strcat(outputfile, ".bin");

  printf("Saving analysis to %s ..\n\n\n", outputfile); 
  
  //Write contents to file
  recordsize = fillFileBuffer(buffer, file, sha1, ib);
  outfile = fopen(outputfile, "ab+");

  //SHA1 and File Header
  fwrite(buffer, sizeof(uint8_t), recordsize, outfile);

  //Instruction buffer
  fwrite(&ib, sizeof(IBuffer), 1, outfile);

  //Renyi Entropy
  fwrite(&r, sizeof(RenyiEntropy), 1, outfile); 

  //MD5 Record
  fwrite(&rmd5, sizeof(MD5Record), 1, outfile); 
  
  //Flush and close output file
  fflush(outfile);
  fclose(outfile);
  exit(EXIT_SUCCESS);
}

